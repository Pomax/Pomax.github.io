<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<atom:link href="http://pomax.github.io/gh-weblog-2/rss.xml" rel="self" type="application/rss+xml" />
<title>Pomax.github.io</title>
<description>My blog on github [Mozilla posts only]</description>
<link>http://pomax.github.io</link>
<lastBuildDate>Thu, 23 Jun 2016 18:12:44 GMT</lastBuildDate>
<pubDate>Thu, 23 Jun 2016 18:12:44 GMT</pubDate>
<ttl>1440</ttl>
<item>
<title> HTTPS, Mixed Content, and the real web... oh my!</title>
<description>&lt;p&gt;We recently fixed something around Mozilla's X-Ray Goggles. A long running problem that caused people headaches and the feeling of lost work, while at the same time doing nothing "wrong", from a technical perspective. This is going to be a story about how modern browsers work, how people use the web, and how those two things... don't always align.&lt;/p&gt;
&lt;h2 id="x-ray-goggles-by-mozilla"&gt;X-Ray Goggles by Mozilla&lt;/h2&gt;
&lt;p&gt;So let's start with X-Ray Goggles: the X-Ray Goggles are &lt;a href="https://goggles.mozilla.org"&gt;a tool&lt;/a&gt; made by &lt;a href="https://mozilla.org"&gt;Mozilla&lt;/a&gt; that lets you "remix" web pages after loading them in your browser. You can go to your favourite place on the web, fire up the goggles (similar to how a professional web developer would open up their dev tools), and then change text, styling, images, and whatever else you might want to change, for as long as you want to change things, and then when you're happy with the result and you want to show your remix to your friends, you can publish that remix so that it has its own URL that you can share.&lt;/p&gt;
&lt;p&gt;However, the X-Ray Goggles use a publishing service that hosts all its content over &lt;code&gt;https&lt;/code&gt;, because we care about secure communication at Mozilla, and using &lt;code&gt;https&lt;/code&gt; is best practice. But in this particular case, it's also kind of bad: large parts of the web still use &lt;code&gt;http&lt;/code&gt;, and even if a website has an &lt;code&gt;https&lt;/code&gt; equivalent, people usually visit the &lt;code&gt;http&lt;/code&gt; version anyway. Unless those websites &lt;em&gt;force&lt;/em&gt; users to the &lt;code&gt;https&lt;/code&gt; version of the site (using a redirect message), then the site they'll be on, and the site they'll be remixing, will use HTTP, and the moment the user publishes their remix with X-Ray Goggles and they get an &lt;code&gt;https&lt;/code&gt; URL back, and then open that URL in their browser....&lt;/p&gt;
&lt;p&gt;well, let's just say "everything looks broken" is not wrong. &lt;/p&gt;
&lt;p&gt;But the reason for this is not because Goggles, or even the browser is doing something wrong - ironically, it's because they're doing something right, and in so doing, what the user wants to do turns out incompatible with what the technology wants them to do. So let's look at what's going on here.&lt;/p&gt;
&lt;h2 id="http-the-basis-upon-which-browsing-is-built"&gt;HTTP, the basis upon which browsing is built&lt;/h2&gt;
&lt;p&gt;If you're a user of the web, no doubt you'll have heard about &lt;code&gt;http&lt;/code&gt; and &lt;code&gt;https&lt;/code&gt;, even if you can't really say what they technically-precisely mean. In simple terms (but without dumbing it down), &lt;a href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol"&gt;HTTP&lt;/a&gt; is the language that servers and browsers use to negotiate data transfers. The original intention was for those two to talk about HTML code, so that's where the &lt;code&gt;h&lt;/code&gt; in &lt;code&gt;http&lt;/code&gt; comes from (it stands for "hypertext" in both &lt;code&gt;http&lt;/code&gt; and &lt;code&gt;html&lt;/code&gt;), but we're mostly ignoring that these days, and HTTP is used by browsers and servers to negotiate transmission of all sorts of files - web pages, stylesheets, javascript source code, raw data, music, video, images, you name it.&lt;/p&gt;
&lt;p&gt;However, HTTP is a bit like regular English: you can listen in on it. If you go to a bar and sit yourself with a group of people, you can listen to their conversations. The same goes for HTTP: in order for your browser and the server to talk they rely on a chain of other computers connected to the internet to get messages relayed from one ot the other, and any of those computers can listen in on what the browser and server are saying to each other. In an HTTP setting it gets a little stranger even, because any of those computers could look at what the browser or server are saying, &lt;em&gt;replace what is being said with something else&lt;/em&gt; and then forward that on. And you'll have no way of knowing whether that's what happened. It's literally as if the postal service took a letter you sent, opened it, rewrote it, resealed it, and then sent that on. We trust that they won't, and computers connected to the internet trust that other computers don't mess with the communication, but... they can. And sometimes they do.&lt;/p&gt;
&lt;p&gt;And that's pretty scary, actually. You don't want to have to "trust" that your communication isn't read or tampered with, you want to &lt;em&gt;know&lt;/em&gt; that's the case.  &lt;/p&gt;
&lt;h2 id="what-can-we-do-to-fix-that-"&gt;What can we do to fix that?&lt;/h2&gt;
&lt;p&gt;Well, we can use &lt;a href="https://en.wikipedia.org/wiki/HTTPS"&gt;HTTPS&lt;/a&gt;, or "secure HTTP", instead. Now, I need to be very clear here: the term "secure" in "secure HTTP" refers to secure &lt;em&gt;communication&lt;/em&gt;. Rather than talking "in English", the browser and server agree on a secret language that you could listen to, but you won't know what's being said, and so you can't intercept-and-modify the communication willy-nilly without both parties knowing that their communications are being tampered with. However it does &lt;strong&gt;not&lt;/strong&gt; mean that the data the browser and server agree to receive or send is "safe data". It only means that both parties can be sure that what one of them receives is what the other intended to send. All we can be sure of is that no one will have been able to see what got sent, and that no one modified it somewhere along the way without us knowing.&lt;/p&gt;
&lt;p&gt;However, those are &lt;em&gt;big&lt;/em&gt; certainties, so for this reason the internet's been moving more and more towards preferring HTTPS for everything. But not everyone's using HTTPS yet, and so we run into something called the &lt;a href="https://developer.mozilla.org/en-US/docs/Security/Mixed_content"&gt;"Mixed Content"&lt;/a&gt; issue.&lt;/p&gt;
&lt;h2 id="let-s-look-at-an-example-"&gt;Let's look at an example.&lt;/h2&gt;
&lt;p&gt;Imagine I run a web page, much like this one, and I run it on HTTP because I am not aware of the security issues, and my page relies on some external images, and some JavaScript for easy navigation, and maybe an embedded podcast audio file. All of those things are linked as &lt;code&gt;http://......&lt;/code&gt;, and everything worked fine.&lt;/p&gt;
&lt;p&gt;But then I hear about the problems with HTTP and the privacy and security implications sound horrible! So, to make sure my visitors don't have to worry about whether the page they get from my server is my page, or a modified version of my page, I spring into action, I switch my page over to HTTPS; I get a &lt;a href="https://en.wikipedia.org/wiki/Public_key_certificate"&gt;security certificate&lt;/a&gt;, I set everything on my own server up so that it can "talk" in HTTPS, and done!&lt;/p&gt;
&lt;p&gt;Except immediately after switching, my web page is completely broken! The page itself loads, but none of the images show up, and the JavaScript doesn't seem to be working, and that podcast embed is gone! What happened??&lt;/p&gt;
&lt;p&gt;This is a classic case of &lt;strong&gt;mixed-content blocking&lt;/strong&gt;. My web page is being served on HTTPS, so it's indicating that it wants to make sure everything is secure, but the resources I rely on still use HTTP, and now the browser has a problem: it can't trust those resources, because it can't trust that they won't have been inspected or even modified when it requests them, and because the web page that's asking them to be loaded expressed that it cares about secure communication a great deal, the browser can't just fetch those insecure elements, things &lt;em&gt;might&lt;/em&gt; go wrong, and there's no way to tell!&lt;/p&gt;
&lt;p&gt;So it does the only thing it knows is safe: better safe than sorry, and it flat out refuses to even request them, giving you a warning about "mixed content".&lt;/p&gt;
&lt;p&gt;Normally, that's great. It lets people who run websites know that they're relying on potentially insecure third party content in an undeniably clear way, but it gets a bit tricky in two situations:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;third party resources that &lt;em&gt;themselves&lt;/em&gt; require other third party resources, and&lt;/li&gt;
&lt;li&gt;embedding and rehosting&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The first is things like your web page using a comment thread service: your web page includes a bit of JavaScript from something like &lt;code&gt;www.WeDoCommentsForYou.com&lt;/code&gt; and then that JavaScript then loads content from that site's comment database, for instance &lt;code&gt;comments.WeDoCommentsForYou.com&lt;/code&gt;. If we have a page that uses HTTPS, running on &lt;code&gt;https://ourpage.org&lt;/code&gt; then we can certainly make sure that we load the comment system from &lt;code&gt;https://www.WeDoCommentsForYou.com&lt;/code&gt;, but we don't control the protocol for the URL that the JavaScript we got back uses. If "WeDoCommentsForYou" wrote their script poorly, and they try to load their comments over &lt;code&gt;http://&lt;/code&gt;, then too bad, the browser will block that. Sure, it's a thing that "WeDoCommentsForYou" should fix, but until they do your users can't comment, and that's super annoying.&lt;/p&gt;
&lt;p&gt;The second issue is kind of like the first, but is about entire web pages. Say you want to embed a page; for instance, you're &lt;a href="https://en.wikipedia.org/wiki/Transclusion"&gt;transcluding&lt;/a&gt; an entire wiki page into another wiki page. If the page you're embedding is &lt;code&gt;http&lt;/code&gt; and the page it's embedded on is &lt;code&gt;https&lt;/code&gt;, too bad, that's not going to work. Or, and that brings us to what I really want to talk about, if you remix a page on &lt;code&gt;http&lt;/code&gt;, with &lt;code&gt;http&lt;/code&gt; resources, and host that remix on a site that uses &lt;code&gt;https&lt;/code&gt;, then that's not going to work either...&lt;/p&gt;
&lt;h2 id="back-to-the-x-ray-goggles"&gt;Back to the X-Ray Goggles&lt;/h2&gt;
&lt;p&gt;And that's the problem we were hitting with X-Ray Goggles, too.&lt;/p&gt;
&lt;p&gt;While the browser is doing the same kind of user protection that it does for any other website, in this particular case it's actually a big problem: if a user remixed an HTTP website, then knowing what we know now, &lt;em&gt;obviously&lt;/em&gt; that's not going to work if we try to view it using HTTPS. But that also means that instead of a cool tool that people can use to start learning about how web pages work "on the inside", the result of which they can share with their friends, they have a tool that lets them look at the insides of a web page and then when they try to share their learning, everything breaks.&lt;/p&gt;
&lt;p&gt;That's not cool.&lt;/p&gt;
&lt;p&gt;And so the solution to this problem is based on first meeting the expectations of people, and then educating them on what those expectations actually mean.   &lt;/p&gt;
&lt;h2 id="give-me-https-unless-i-started-on-http"&gt;Give me HTTPS, unless I started on HTTP&lt;/h2&gt;
&lt;p&gt;There are quite a few solutions to the mixed-content problem, and some are better than others. There are some that are downright not nice to other people on the web (like making a full copy of someone's website and then hosting that on Mozilla's servers. That's not okay), or may open people up exploits (like running a proxy server, which runs on HTTPS and can fetch HTTP resources, then send them on as if they were on HTTPS, effectively lying about the security of the communication), so the solution we settled on is, really, the simplest one:&lt;/p&gt;
&lt;p&gt;If you remix an &lt;code&gt;http://...&lt;/code&gt; website, we will give you a URL that starts with &lt;code&gt;http://&lt;/code&gt;, and if you remix an &lt;code&gt;https://&lt;/code&gt; website, we will give you a URL that starts with &lt;code&gt;https://...&lt;/code&gt;. However, we also want you to understand what's going on with the whole "&lt;code&gt;http&lt;/code&gt; vs &lt;code&gt;https&lt;/code&gt;" thing, so when you visit a remix that starts with &lt;code&gt;http://&lt;/code&gt; the remix notice bar at the top of the page also contains a link to the &lt;code&gt;https://&lt;/code&gt; version --same page, just served using HTTPS instead of HTTP-- so that you can see exactly how bad things get if you can't control which protocol gets used for resources on a page.&lt;/p&gt;
&lt;h2 id="security-vs-usability"&gt;Security vs Usability&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.mozilla.org/en-US/security"&gt;Security is everybody's responsibility&lt;/a&gt;, and explaining the risks on the web that are inherent to the technology we use every day is always worth doing. But that doesn't mean we need to lock everything down so "you can't use it, the end, go home, stop using HTTP". That's not how the real world works.&lt;/p&gt;
&lt;p&gt;So we want you to be able to remix your favourite sites, even if they're HTTP, and have a learning/teaching opportunity there around security. Yes, things will look bad when you try to load an HTTP site on HTTPS, but there's a reason for that, and it's important to talk about it.&lt;/p&gt;
&lt;p&gt;And it's equally important to talk about it without making you lose an hour or more of working on your awesome remix.&lt;/p&gt;
</description>
<category>Mozilla</category>
<category>X-Ray Goggles</category>
<category>http</category>
<category>https</category>
<category>browsers</category>
<category>internet</category>
<link>http://pomax.github.io/#gh-weblog-1462301193409</link>
<guid>http://pomax.github.io/#gh-weblog-1462301193409</guid>
<pubDate>Tue, 03 May 2016 18:46:33 GMT</pubDate>
</item>
<item>
<title> Developing Open Source Software</title>
<description>&lt;p&gt;I want to take a little bit of time to explain how I work on Open Source, both privately and as part of my job as a Software Engineer at the Mozilla Foundation. Not because it's wildly different from how everyone else does it, but because it's probably the same as how the vast majority works on Open Source, which means very few people bother to explain the processes involved.&lt;/p&gt;
&lt;p&gt;There are two different kinds of "working on open source", depending on whether the code is a collaboration or just a simple one-person project, so let's look at both.&lt;/p&gt;
&lt;h2 id="-i-m-making-a-thing-"&gt;&lt;em&gt;"I'm making a thing!"&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;If you're making a thing, the basic rule is "anything goes": you're the only one you're inconveniencing by taking shortcuts, and often that's fine. However, if you're starting a project that you think might at some point gain contributors (say, you're making a thing that you hope becomes popular), there are a few things you can do to make sure that when your project does go from "one dev" to "a team", the transition is smooth:&lt;/p&gt;
&lt;h3 id="file-issues-before-fixing-them"&gt;File issues before fixing them&lt;/h3&gt;
&lt;p&gt;Not only is it a handy If you file the issues you know about as a kind of to-do list to walk through, but you might be surprised to find someone actually fixing an issue you filed before you get to it, once your project gets even a little exposure.&lt;/p&gt;
&lt;h3 id="work-in-branches-"&gt;Work in branches.&lt;/h3&gt;
&lt;p&gt;There will be an initial "I just need to get this code written" period where you're pushing to master: awesome, go for it. However, once you reach what might turn into a 1.0 with a bit more code, start getting in the habit of treating your master branch as off limits, and working in branches that you merge into master instead. This makes it easier for contributors to do the same.&lt;/p&gt;
&lt;h3 id="document-document-document-"&gt;Document, document, document.&lt;/h3&gt;
&lt;p&gt;You're not actually working on your code alone: you're collaborating with your future self, and future self has no idea what you're thinking right now while you're writing your code: document your choices, explain complex bits of code and whatever you do, explain hacks and bodges! Clever as they might be today, 2 months from now they might be so clever you actually need to spend your own time on them to figure out why they even work the way they do. Help future-you out: write documentation.&lt;/p&gt;
&lt;p&gt;And that doesn't need to be wikis or long readmes, it can just be code comments: as long as knowledge you need to understand changes you're making right now isn't lost, you're being awesome. &lt;/p&gt;
&lt;h2 id="-we-re-making-a-thing-"&gt;&lt;em&gt;We're making a thing.&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;While you're fairly free to do what you want to do on your own, for collaborative projects, there is really only one way to work in a way that's not going to break down. For anything that needs to be done, follow the three F's:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;File it&lt;/strong&gt;,&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Fix it&lt;/strong&gt;, and&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Follow up&lt;/strong&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="1-file-it-"&gt;1) File it!&lt;/h3&gt;
&lt;p&gt;If you're going to work on something, make sure it's a known issue. Code changes without an issue that explain why the changes were necessary in the first place are mystery changes, and mysteries in a collaborative effort are bad.&lt;/p&gt;
&lt;p&gt;However, that doesn't mean the changes aren't necessary, so: always, &lt;strong&gt;always&lt;/strong&gt; make sure there's a ticket, or issue, or bug report, associated with the changes you're making, so that your code changes can say "this fixes/addresses ticket/issue/bug so-and-so". Sometimes those tickets/issues/bug reports already exist and you can simply refer to them, but sometimes they don't: &lt;strong&gt;file it before submitting your code changes&lt;/strong&gt;, so that you can refer to that newly filed ticket.&lt;/p&gt;
&lt;p&gt;It's okay to already have the code in place that addresses an issue you haven't filed yet, just make sure that by the time you submit your changes, there is one.&lt;/p&gt;
&lt;p&gt;Collaboration relies on communication. If people change the code without tying it to the list of "these are issues we need to address", then there is no way to track changes in the codebase. Generating a changelog based on closed issues is often quite easy, but if there are no issues that got closed/resolved due to changes getting accepted into the code base, then you're asking people to work on code that potentially no one can explain (because the person who contributed it may have left already. If you can even track who submitted the change at all).&lt;/p&gt;
&lt;p&gt;Also, &lt;strong&gt;file individual issues&lt;/strong&gt;. The best code bases are ones where each thing that needs to be done is filed separately, and fixed separately, because it's much easier to work on as a team (small tasks make for rapid progress), and it makes it easy to track complex tasks: if you need to implement a user profile system, and that requires a login system, a user database, and user facing UI, then if someone files "implement a user profile system", the very first thing that should happen is chopping that issue up into several smaller issues. It might sound anal, but you're working in a team, and many hands make light work: the smaller you can chop up an issue, the easier it becomes to resolve the bigger task.&lt;/p&gt;
&lt;h3 id="2-fix-it-"&gt;2) Fix it...&lt;/h3&gt;
&lt;p&gt;Crazy as it may sound: never start fixing things by writing code. First ask: "Has someone else already written the code and can I just plug that in?". If they have: just use that. You're still probably going to need a little bit of code to do the "plugging it in" part, but little bits of code are easy to maintain, and it means you're not responsible for maintaining lots of code.&lt;/p&gt;
&lt;p&gt;Conversely, if there is no code out there that already does what you need to do, ask yourself: "Can I write this as a standalone utility, and then plug &lt;em&gt;that&lt;/em&gt; in?". Because if you can, that's worth doing. If you need to solve a problem and there's no solution out there, you're probably solving a problem that other people are also having: it's worth making that solution available.&lt;/p&gt;
&lt;p&gt;Of course, there will be plenty of issues that can only be addressed by writing real, project-relevant, code, and for those occasions there are three things to keep in mind:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;commit early&lt;/strong&gt;,&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;commit often&lt;/strong&gt;, and&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;communicate with your team&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="commit-early"&gt;Commit early&lt;/h4&gt;
&lt;p&gt;If you're working on code changes, push up your changes as soon as you have "something" going. &lt;strong&gt;Especially if it's not done yet&lt;/strong&gt;. Don't wait until "it's done", because you have no idea when that will be: form a commit and push it up once you have the basic stubs in place, for instance, before you start working out the code in full.&lt;/p&gt;
&lt;p&gt;This lets other people that work with you see what you're working on, and lets them catch things early that would cost a lot of time to fix later on. &lt;/p&gt;
&lt;h4 id="commit-often"&gt;Commit often&lt;/h4&gt;
&lt;p&gt;Some code changes are one liners or a simple function renaming, but many are not: don't wait until you're done to push up your changes. Any time you write some code and test it, and it passes, that's a moment to form a commit, push it up, and then keep going.&lt;/p&gt;
&lt;p&gt;If a computer dies (and if you work in a team, that will happen surprisingly often) or someone unexpectedly becomes unavailable for a few days (again, happens more often than you might think), there is no loss of work &lt;strong&gt;for the team&lt;/strong&gt;. The team as a whole can pick up where you as a person left off in these circumstances, and if you don't commit often, they'll potentially have to reinvent changes you had already written.&lt;/p&gt;
&lt;p&gt;It's also much easier to rebase your code if they're small incremental commits when the master code base changes. For instance, a dependency got updated, which caused some functions to use that dependency's new API calls; that is much easier to deal with if it just requires you to change the small commit that touched a file for which that was the case than if you have one massive commit.&lt;/p&gt;
&lt;p&gt;Additionally, the more often you commit, the earlier possible bugs can be found; the earlier bugs are found, the less work it is to fix them, because not a lot of things will trigger them yet.&lt;/p&gt;
&lt;h4 id="communicate-with-your-team"&gt;Communicate with your team&lt;/h4&gt;
&lt;p&gt;If you're working on anything even moderately sized: start talking about your code with team members early. Don't ask them to review only all the way at the end if your changes involve new code or new approaches; run it by someone so that even if you're the only one that'll end up writing code, you're &lt;em&gt;not&lt;/em&gt; the only one who knows what decisions were made while the code was being written.&lt;/p&gt;
&lt;p&gt;Also, remember to ask questions in the open. You might end up with blocking questions that need an answer before you can continue your work, and while it's tempting to try to find someone to get it answered in real-time, &lt;strong&gt;file it first&lt;/strong&gt;, so that the entire team can see it. Then you can find someone to real-time answer it and capture the answer in the filed issue, so that the entire team can be aware of the question having come up, and the answer that was agreed on.&lt;/p&gt;
&lt;h4 id="corrolary-know-when-to-split-your-work-"&gt;Corrolary: know when to split your work.&lt;/h4&gt;
&lt;p&gt;Some issues reveal problems in other parts of the project, and you might be tempted to fix those as part of your changes. I know it's tempting, but &lt;strong&gt;don't&lt;/strong&gt;, because you're not actually helping the team that way. Instead: file it, fix it, and follow up.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Step away from the current code when you reach a good break point (and that could be immediately, if the thing you found is blocking you),&lt;/li&gt;
&lt;li&gt;File the issue as a new issue,&lt;/li&gt;
&lt;li&gt;If it's blocking you:&lt;ol&gt;
&lt;li&gt;Fix it first,&lt;/li&gt;
&lt;li&gt;Schedule follow up&lt;/li&gt;
&lt;li&gt;Rebase your code on the fix, so you're unblocked&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Now you can come back to the code you were already working on.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;You'll note that in step 3 the advice is to work on it immediately only if it's actually blocking you: this is important. You're working in a team, and someone else might have a free moment to work on the thing you just discovered, while you keep working on your own changes.&lt;/p&gt;
&lt;h3 id="3-run-through-the-follow-up-"&gt;3) Run through the follow-up.&lt;/h3&gt;
&lt;p&gt;You've worked on code changes, you committed early, and often, and your "patch" now consists of 12 commits and two observations about future work: it's time for follow-up.&lt;/p&gt;
&lt;h4 id="clean-up-your-code"&gt;Clean up your code&lt;/h4&gt;
&lt;p&gt;If your changes work using 12 commits, then your changes work, and it's time to squash those 12 commits into a single commit so it can be landed into the codebase without all the steps that got you there. Even if there is no requirement to squash your code before landing, changelog generation, revision control, and rollbacks are all much nicer if patches land as single commits.&lt;/p&gt;
&lt;p&gt;Also, if there are any unnecessary comments or logs/prints in your code, now's the time to get rid of those, and of course, now is also the time to make sure that any missing documentation either gets added, or gets filed as "document XYZ", to be worked on immediately after landing your changes, rather than anything else, which brings us to...&lt;/p&gt;
&lt;h4 id="file-anything-you-found-but-didn-t-fix-"&gt;File anything you found, but didn't fix.&lt;/h4&gt;
&lt;p&gt;While you were working on your changes, you may have thought of things that might need addressing outside of the changes you made: &lt;strong&gt;file those&lt;/strong&gt;. It is important to capture those observations in a way that the entire team can see them.&lt;/p&gt;
&lt;h4 id="talk-to-your-team"&gt;Talk to your team&lt;/h4&gt;
&lt;p&gt;Finally, follow up with people, too. Let the people who need to know about your changes know about your changes - ask them to review you patch, explain your work to them where needed, if there is testing involved, make sure they understand what needs to be done, and generally make sure at least two people agree these changes are good to go (including yourself). That communication doesn't need to happen in person, the issue tracker you use might facilitate this kind of follow up, but always collaborate on the landing, even if the code works. There might be last minute changes or decisions that you were not aware of that someone else might: good to discover that before the changes are merged in!&lt;/p&gt;
&lt;h2 id="that-s-pretty-much-it"&gt;That's pretty much it&lt;/h2&gt;
&lt;p&gt;There's a fair amount of finer detail and variation that fits into the "file it, fix it, follow up" process, but stick to that order and you're on the path of a sustainable development cycle.&lt;/p&gt;
&lt;p&gt;Most of this is probably obvious to most people, but that just makes it all the more important to get it written down, because someone's going to be a bit bewildered and they'll need a blog post to get them on track =)&lt;/p&gt;
</description>
<category>Open source</category>
<category>Development</category>
<category>Process</category>
<category>Mozilla</category>
<link>http://pomax.github.io/#gh-weblog-1450207129290</link>
<guid>http://pomax.github.io/#gh-weblog-1450207129290</guid>
<pubDate>Tue, 15 Dec 2015 19:18:49 GMT</pubDate>
</item></channel>
</rss>
