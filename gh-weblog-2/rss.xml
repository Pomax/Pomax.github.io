<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<atom:link href="http://pomax.github.io/gh-weblog-2/rss.xml" rel="self" type="application/rss+xml" />
<title>Pomax.github.io</title>
<description>My blog on github</description>
<link>http://pomax.github.io</link>
<lastBuildDate>Fri, 02 Dec 2016 17:52:14 GMT</lastBuildDate>
<pubDate>Fri, 02 Dec 2016 17:52:14 GMT</pubDate>
<ttl>1440</ttl>
<item>
<title>I built a spice rack to fit our 72 mason jars of spices and herbs</title>
<description>&lt;p&gt;And it didn't even take all that long to do! It also took a bit to properly document so rather than repeat information on the internet, I will link to where I photo-documented the fabrication process and you can give that a read-through in case you ever want to do this yourself.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;78 image step-by-step documented album on imgur: &lt;a href="http://imgur.com/gallery/FIb3S"&gt;http://imgur.com/gallery/FIb3S&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Imgur comments with many good questions and pieces of advice: &lt;a href="http://imgur.com/gallery/FIb3S#comments"&gt;http://imgur.com/gallery/FIb3S#comments&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Reddit comments with many good questions and pieces of advice: &lt;a href="https://www.reddit.com/r/DIY/comments/5e2m5x/i_made_a_spice_rack_to_fit_72_mason_jars_worth_of"&gt;https://www.reddit.com/r/DIY/comments/5e2m5x/i_made_a_spice_rack_to_fit_72_mason_jars_worth_of&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/pwwAkNA.jpg" alt="The finished spice rack"&gt;&lt;/p&gt;
</description>

<link>http://pomax.github.io/#gh-weblog-1480700902037</link>
<guid>http://pomax.github.io/#gh-weblog-1480700902037</guid>
<pubDate>Fri, 02 Dec 2016 17:48:22 GMT</pubDate>
</item>
<item>
<title> If you use use document.write, you suck at JavaScript</title>
<description>&lt;p&gt;Wow, that's an incendiary post title isn't it. Just because you use &lt;code&gt;document.write&lt;/code&gt; doesn't say anything about your JavaScript skills, I mean it's just another function in the official ECMAScript spec, it's just an older one. Why the vitriol?&lt;/p&gt;
&lt;h2 id="let-s-start-at-the-start"&gt;Let's start at the start&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;document.write&lt;/code&gt; function comes to us from the dark ages of the early JavaScript enabled web, and is really nothing like the JS you are likely to be familiar with.  It might be called &lt;code&gt;document.write&lt;/code&gt; and invoked as if it's part of the document API, &lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/Document/write"&gt;its true behaviour is much lower level&lt;/a&gt;: it is a proxy function in to the bytesteam pipe that defines what's even &lt;strong&gt;in&lt;/strong&gt; your &lt;code&gt;document&lt;/code&gt;. The &lt;code&gt;write&lt;/code&gt; function doesn't let you "write some data into the document", it &lt;strong&gt;is&lt;/strong&gt; the document, and that comes with some hilarious side effects.&lt;/p&gt;
&lt;h2 id="1-write-needs-an-open-pipe"&gt;1: &lt;code&gt;write&lt;/code&gt; needs an open pipe&lt;/h2&gt;
&lt;p&gt;Say you have a web page, and that webpage has the following code:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;html&amp;gt;
  &amp;lt;head&amp;gt;&amp;lt;title&amp;gt;whatever&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;script&amp;gt; document.write("&amp;lt;p&amp;gt;oh look a paragraph&amp;lt;/p&amp;gt;"); &amp;lt;/script&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The browser loads this code by creating a &lt;code&gt;document&lt;/code&gt;, opening it for writing, piping that data into it (which gets parsed into a DOM as it sees bytes flying by) and then closes it to signal the completion of building &lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model"&gt;the DOM&lt;/a&gt; for your page.&lt;/p&gt;
&lt;p&gt;Given that, you might expect this code to write a paragraph into your document at the time that the &lt;code&gt;document.write&lt;/code&gt; script triggers. And you'd be right, but here is &lt;em&gt;why&lt;/em&gt; you're right: as the document pipe is still open, and the script element gets evaluated &lt;em&gt;while&lt;/em&gt; the document is getting parsed, the document parser simply sees "more bytes" flying by to parse into the DOM.&lt;/p&gt;
&lt;p&gt;Want to see something hilarious?&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;html&amp;gt;
  &amp;lt;head&amp;gt;&amp;lt;title&amp;gt;whatever&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;script&amp;gt;
      document.addEventListener("DOMContentLoaded", function() {
        document.write("&amp;lt;p&amp;gt;oh look a paragraph&amp;lt;/p&amp;gt;");
      });
    &amp;lt;/script&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Guess what that does. If you thought "it writes a paragraph into the document once it's finished loading" then: no, not really.  While it might look that way if you put this in jsbin or the like that's what it looks like it does, but let's try this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;html&amp;gt;
  &amp;lt;head&amp;gt;&amp;lt;title&amp;gt;whatever&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;h1&amp;gt;Second test:&amp;lt;/h1&amp;gt;
    &amp;lt;script&amp;gt;
      document.addEventListener("DOMContentLoaded", function() {
        document.write("&amp;lt;p&amp;gt;oh look a paragraph&amp;lt;/p&amp;gt;");
      });
    &amp;lt;/script&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Run this code. Seriously, hit up &lt;a href="https://jsbin.com"&gt;jsbin&lt;/a&gt; and paste that into the HTML section, then run it. See what happens.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Huh, where did that &lt;code&gt;&amp;lt;h1&amp;gt;&lt;/code&gt; go?&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Actually, the correct question is "where did &lt;strong&gt;everything&lt;/strong&gt; go?" because your entire document got wiped. After all, &lt;code&gt;document.write&lt;/code&gt; needs an open pipe, and there is no open pipe once all content has loaded. And so it makes one.&lt;/p&gt;
&lt;p&gt;A new one.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;An empty one&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;document&lt;/code&gt; is now an empty, open data pipe&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;What happened? The document got opened, the source code bytes went flying past the parser, it saw the end of the document, the document got closed for writing, and then when it sends the signal "DOM finished building!", our &lt;code&gt;document.write&lt;/code&gt; code kicks in, and the document is reopened as a new, empty, byte stream, and we pump in only the bytes &lt;code&gt;&amp;lt;p&amp;gt;oh look a paragraph&amp;lt;/p&amp;gt;&lt;/code&gt;. The browser knows how to auto-inject missing tags so it'll automatically build the higher level &lt;code&gt;html&lt;/code&gt;, &lt;code&gt;head&lt;/code&gt; and &lt;code&gt;body&lt;/code&gt; nodes in the DOM, but the &lt;em&gt;only&lt;/em&gt; data in our document as far as the browser knows is now &lt;code&gt;&amp;lt;p&amp;gt;oh look a paragraph&amp;lt;/p&amp;gt;&lt;/code&gt;, and &lt;strong&gt;nothing else&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;So congratulations, you actually just wiped the page! And this is not a "quirk", this is literally what it's supposed to do, it's intended and explicit behaviour. If this was code you wrote on your own page, then lucky you, easy to fix (don't use &lt;code&gt;document.write&lt;/code&gt;) but if this was a 3rd party library, good luck finding out which one is  responsible. And then replacing it with a modern library instead.&lt;/p&gt;
&lt;h2 id="2-document-write-is-insanely-insecure-"&gt;2.  &lt;code&gt;document.write&lt;/code&gt; is insanely insecure.&lt;/h2&gt;
&lt;p&gt;You probably know that &lt;code&gt;eval()&lt;/code&gt; is really bad because it can evaluate arbitrary JS code, with the same execution rights as the page it's run on. So... you should see this one coming, but &lt;code&gt;document.write&lt;/code&gt; lets you do exactly the same thing. In fact, it's the most low-level version of eval you can come up with: it's &lt;em&gt;literally&lt;/em&gt; the function for injecting data into a page, so let's do that...&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;html&amp;gt;
  &amp;lt;head&amp;gt;&amp;lt;title&amp;gt;whatever&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;script src="https://third.party.domain/perfectly-safe.js"&amp;gt;&amp;lt;/script&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;and let's put a &lt;code&gt;document.write&lt;/code&gt; in that "perfectly safe" js file!&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;document.write("&amp;lt;script&amp;gt; do.anything(); &amp;lt;/script&amp;gt;");
/*
  awesome,  this injected code will run as if it's part of the page this is run on,
  not our http://third.party.domain context, so it will have access to everything
  security related that we shouldn't ever have access to!
*/
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Good times!&lt;/p&gt;
&lt;h2 id="3-document-write-is-synchronous"&gt;3.  &lt;code&gt;document.write&lt;/code&gt; is synchronous&lt;/h2&gt;
&lt;p&gt;Because we can't defer &lt;code&gt;document.write&lt;/code&gt; to after the document is done loading, all the &lt;code&gt;document.write&lt;/code&gt; code &lt;em&gt;has&lt;/em&gt; to run as part of the initial page load, and so anything it puts in your document increases time-to-load. If you are blessed enough to live in a part of the world where you've never noticed page load speed, good for you! But a &lt;em&gt;lot&lt;/em&gt; of people are still on slow connections, and any page blocking before the browser can show an initial view (which it only does once it reaches the &lt;code&gt;&amp;lt;/body&amp;gt;&lt;/code&gt; tag) is extremely obvious.&lt;/p&gt;
&lt;h2 id="okay-fine-but-say-i-know-all-these-things-why-do-i-suck-at-javascript-if-i-use-it-i-know-what-i-m-doing-"&gt;Okay, fine, but say I know all these things, why do I suck at JavaScript if I use it? I know what I'm doing!&lt;/h2&gt;
&lt;p&gt;I'm going to  argue that you don't. Not necessarily through any fault of your own, but you can still suck at something even if you don't realise you do.&lt;/p&gt;
&lt;p&gt;Modern JS has many constructions that are non-destructive, secure, and non-blocking. Why not use those instead? And that's a rhetorical question, really: you &lt;em&gt;should&lt;/em&gt; be using the modern JS equivalents, not a low-level document bytecode writer. It doesn't really matter what you want to do, because I know what you don't want to do: you don't want to "write byte data into the document", you want to do something else.&lt;/p&gt;
&lt;p&gt;As such, like any proper solution to &lt;a href="http://meta.stackexchange.com/questions/66377/what-is-the-xy-problem"&gt;an XY problem&lt;/a&gt;, solve the right problem with the right tools. In this case, do what you &lt;em&gt;actually&lt;/em&gt; want to get done using the appropriate modern APIs for doing that thing; don't resort to &lt;code&gt;document.write&lt;/code&gt; as some kind of magical hammer, because then you're just abusing &lt;code&gt;document.write&lt;/code&gt; to do something it wasn't designed to do, in a way that is horrendously broken and bug-prone.&lt;/p&gt;
&lt;p&gt;So what do you use instead?&lt;/p&gt;
&lt;h3 id="adding-content-to-the-document"&gt;Adding content to the document&lt;/h3&gt;
&lt;p&gt;The proper way to add content to your document, using modern, non-destructive code, is by using the DOM manipulation API. In vanilla JS, things like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;html&amp;gt;
  &amp;lt;head&amp;gt;&amp;lt;title&amp;gt;whatever&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;h1&amp;gt;Second test:&amp;lt;/h1&amp;gt;
    &amp;lt;script&amp;gt;
      document.addEventListener("DOMContentLoaded", function() {
        var body = document.body.
        var p = document.createElement("p");
        p.textContent = "wow, a new paragraph!";
        body.appendChild(p);
      });
    &amp;lt;/script&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Is that cumbersome? Sure is, so if you have to manipulate the DOM, use something like jQuery or Zepto or the like instead, because they give you far easier APIs, while making sure to fall through to proper DOM manipulation instead of &lt;code&gt;document.write&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;html&amp;gt;
  &amp;lt;head&amp;gt;&amp;lt;title&amp;gt;whatever&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;h1&amp;gt;Second test:&amp;lt;/h1&amp;gt;
    &amp;lt;script&amp;gt;
      $(function() {
        $(document.body).append($("&amp;lt;p&amp;gt;Wow, a new paragraph!&amp;lt;/p&amp;gt;");
      });
    &amp;lt;/script&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Done.  And it runs asynchronous, too, so your page isn't blocked from loading.&lt;/p&gt;
&lt;h3 id="but-i-only-use-document-write-to-see-debug-information-"&gt;But I only use &lt;code&gt;document.write&lt;/code&gt; to see debug information!&lt;/h3&gt;
&lt;p&gt;Okay... wait, what? Why are you doing that? It's 2016, but even if this was 2010: use the &lt;code&gt;console&lt;/code&gt; API, because that's what it's for.&lt;/p&gt;
&lt;p&gt;You open your browser's dev tools view, and you use &lt;code&gt;console.log(...)&lt;/code&gt; to write data to the dev tools console. In fact, unlike &lt;code&gt;document.write&lt;/code&gt; which can only write strings (obviously), &lt;code&gt;console.log&lt;/code&gt; can write everything you throw at it, and can write as many things as you need written in a single command. Strings, arrays, full objects, it makes all those things accessible in the console in an explorable way, and in a single call: &lt;code&gt;console.log("test", [1,2,3], {x:0,y:undefined})&lt;/code&gt; just works.&lt;/p&gt;
&lt;p&gt;In fact, because being explicit about your intent in code is important for your code to make sense not just to others but even to your future self, the console API even has things like &lt;code&gt;console.warn()&lt;/code&gt; and &lt;code&gt;console.error()&lt;/code&gt;, so you can be specific about what your debug is for (just "see the data" vs "strong signal that something's wrong"). And if you want to get &lt;em&gt;really&lt;/em&gt; fancy there's things like &lt;code&gt;console.table()&lt;/code&gt; for pretty-printing specific data in tabulated form. &lt;/p&gt;
&lt;p&gt;The console is amazing and you should be using it. Not &lt;code&gt;document.write&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id="but-what-if-i-use-it-for-"&gt;But what if I use it for--&lt;/h3&gt;
&lt;p&gt;I kind of stopped caring: whatever you're doing, there is a modern JS way to do that without using &lt;strong&gt;a bare-bones byte injection function hooked into the normally inaccessible document byte map&lt;/strong&gt;. &lt;/p&gt;
&lt;h3 id="no-really-i-m-using-it-for-injecting-a-filesystem-loader-into-an-iframe-that-kicks-in-before-the-document-even-exists-replacing-it-with-a-posix-filesystem-enabled-mini-server-that-"&gt;No really, I'm using it for injecting a filesystem loader into an iframe that kicks in before the document even exists, replacing it with a POSIX filesystem-enabled mini server that--&lt;/h3&gt;
&lt;p&gt;That sounds awesome, I did the same thing! Also, that's an amazeballs super-ninja insane-o-hack, so I hope you're not counting on that working forever, because &lt;code&gt;document.write&lt;/code&gt; has to go. No matter how neat the thing is we can achieve by abusing the hell out of it. Our exploits of it are not enough to justify keeping it around.&lt;/p&gt;
&lt;p&gt;Seriously: &lt;em&gt;&lt;code&gt;document.write&lt;/code&gt; has to go.&lt;/em&gt;&lt;/p&gt;
&lt;h1 id="do-you-really-suck-at-javascript-probably-not-"&gt;Do you &lt;em&gt;really&lt;/em&gt; suck at JavaScript? Probably not.&lt;/h1&gt;
&lt;p&gt;So back to the original proposition. Do you suck at JavaScript? Well, sort of. You're using a function you shouldn't ever have been taught to use. That happens. We all started at a position of "knowing nothing about JavaScript", so not knowing how bad &lt;code&gt;document.write&lt;/code&gt; is, is kind of a given. However, now you know, and now you need to go and find all those places where you use it.&lt;/p&gt;
&lt;p&gt;And then do you suck at JavaScript? Well, that depends on what you do next: if you don't stop using &lt;code&gt;document.write&lt;/code&gt; now, and you don't go an correct your past mistakes, then yes; you absolutely suck at JavaScript, and the web world is worse off because of you. No two ways about it: if that's you, you're part of the problem. And not even because of &lt;code&gt;document.write&lt;/code&gt; anymore but because you are unwilling to fix obviously bad behaviour. You have problems well outside of writing JavaScript.&lt;/p&gt;
&lt;p&gt;So shape up, and help everyone learn better JS by writing better JS. You have the skills and the power, exercise them, make a diffrence.&lt;/p&gt;
&lt;p&gt;And to all of you already avoiding &lt;code&gt;document.write&lt;/code&gt; like the low-level legacy function that it is: good on you, keep up the good work. Maybe convince a friend to do the same, tweet about it, write a blog post; together we can fix the web.&lt;/p&gt;
</description>
<category>JavaScript</category>
<category>Web dev</category>
<category>document.write</category>
<link>http://pomax.github.io/#gh-weblog-1473270609919</link>
<guid>http://pomax.github.io/#gh-weblog-1473270609919</guid>
<pubDate>Wed, 07 Sep 2016 17:50:09 GMT</pubDate>
</item>
<item>
<title>So... I ruined my hands (but they're getting better)</title>
<description>&lt;p&gt;About two weeks ago, I was fixing my favourite ramen bowl using traditional Japanese pottery repair techniques, which involves working with "urushi", a natural laquer obtained from the &lt;a href="https://en.wikipedia.org/wiki/Chinese_laquer_tree"&gt;Chinese Laquer Tree&lt;/a&gt;. This might not mean anything to you, until I explain to you that there is a compound known to science called "urushiol" that is found in poison ivy, poison oak, poison sumac, cashew trees, and other such nasty plants, and that is causes massive reactions in a large portion of humans.&lt;/p&gt;
&lt;p&gt;Urushi is what that compound is named after, and while I wore gloves while working on my ramen bowl, I took them off before cleaning up. And so I ended up with &lt;a href="https://en.wikipedia.org/wiki/Urushiol-induced_contact_dermatitis"&gt;urushiol-induced contact dermatitis&lt;/a&gt;. The nasty thing about it is that it doesn't kick in immediately. As an antigen reaction, the first time this happens it takes one to two weeks before your body reacts to it, but like any good antigen reaction, the second time it only takes a few days. However, a "a few days" is not "immediately" and so you don't realise you screwed up until three days later, when it's too late: this is happening, better make your peace with it.&lt;/p&gt;
&lt;p&gt;And making your peace with it is hard: the affected skin will start to rash and blister, and those blisters will just get bigger and bigger, spawning blisters INSIDE of them, and joining up to form huge finger-spanning blisters with smaller blisters inside of them. If that sounds horrible, good news: it's even worse because it also itches like &lt;em&gt;mad&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;There are some ways to mitigate it, and none of them are drugs or creams: the most effective way to deal with the itching is to soak the affected region (if possible) in super hot water. As hot as you can stand, and then just a fraction hotter. It desensitizes the tissue and alleviates the itching for at least a few hours. And after a week, the blisters start to recede again once the body finally figures out that none of its defenses are actually doing anything (no kidding, if only we could tell it that earlier), and then the rest of your body starts to catch up: any part of your body that undergoes repeated skin stress (bits that chafe up against clothing, a scrape you got from walking into a door handle, and so on) develops a rash, too. No blisters, but you'll enjoy swelling and rashing and massive itchiness a second time over.&lt;/p&gt;
&lt;p&gt;Now, that sounds horrible, and it kind of is, but the most annoying part is that once you realise what's happening, it's a) too late and b) you're going to lose the functionality of whatever got the blister part of the deal. In my case, my left hand blistered up so badly that I couldn't use it, and my right was pretty close too. I ended up buying curator's gloves just so that moving my fingers ever so slightly wouldn't make blisters rub up against blisters, causing itching and pain.&lt;/p&gt;
&lt;p&gt;Does that sound gross? Good: &lt;strong&gt;wear gloves when working with urushi, and wear clothes if you're in a poison ivy/poison oak region&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Seriously, it'll take you down, and if you live in North America, your doctor's just going to prescribe antibiotics and a topical cream, neither of which will actually do anything to make you heal faster - they're just overreactions to "you might scratch yourself open and get an infection O_O" (protip: don't scratch. Yeah it itches like crazy, suck it up. 2 weeks from now you won't remember itching 2 weeks ago). You have to ride it out, and you have to not scratch, and you will be driven close to mad, while not being able to do your job.&lt;/p&gt;
&lt;p&gt;Don't be like me.&lt;/p&gt;
</description>
<category>Urushi</category>
<category>Poison Ivy</category>
<category>Poison Oak</category>
<category>Safety</category>
<link>http://pomax.github.io/#gh-weblog-1469494036040</link>
<guid>http://pomax.github.io/#gh-weblog-1469494036040</guid>
<pubDate>Tue, 26 Jul 2016 00:47:16 GMT</pubDate>
</item>
<item>
<title> Live commentary is soul-destroying</title>
<description>&lt;p&gt;I started a Youtube channel called &lt;a href="https://www.youtube.com/channel/UC_vhEBO8O9ABn1f32KuUtjw"&gt;Baking McCookery&lt;/a&gt; a while ago for recording things I make in the kitchen, and for a while these were overhead and stove videos with text overlays, and that worked rather well, but they were silent, and that doesn't work all that well.&lt;/p&gt;
&lt;p&gt;As such, people suggested getting a mic and talking while cooking, to capture more of the process. And that sounded like a good idea! So I did - I bought a &lt;a href="https://www.amazon.ca/gp/product/B01EWSD17E"&gt;cheap(ish) voice recorder&lt;/a&gt; and decent &lt;a href="https://www.amazon.ca/gp/product/B00PQYMFU8"&gt;lavalier microphone&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Except having ruined five recording sessions now over audio problems, clipped signals, stutters, and general commentary problems that sync up with the video in a way that they can't be cut out has actually left me extremely depressed over the whole venture, and that was never the point of these videos: this was supposed to be fun.&lt;/p&gt;
&lt;p&gt;Working in the kitchen is a thing that directly influences my emotional state: making delicious food makes me happy, and ruining food gets me angry and depressed, and spending hours in a kitchen only to end up with failures this many times means I'm doing this wrong: I've allowed a hobby to become a depression, and it's time to cut that off.&lt;/p&gt;
&lt;p&gt;So: after ending up with only a single session that was even remotely passable (and even then, had clipped audio - I might eventually redo it without audio and just consider that playlist a lost cause to be deleted) I'm going back to text overlays. Sure, I might add some background music, and I will think about whether post-commentary is an option, but for now I want to enjoy my life in the kitchen again. And that means overhead and stove videos that let me &lt;a href="http://wouldeatagain.ca/2016/07/10/chocolate-bread-pudding"&gt;do what I love most&lt;/a&gt;, without having to divide my focus between "doing the thing I love" and "talking about the thing I'm doing".&lt;/p&gt;
</description>
<category>Youtube</category>
<category>Videography</category>
<category>Quality of Life</category>
<link>http://pomax.github.io/#gh-weblog-1468256151147</link>
<guid>http://pomax.github.io/#gh-weblog-1468256151147</guid>
<pubDate>Mon, 11 Jul 2016 16:55:51 GMT</pubDate>
</item>
<item>
<title>Mobile photography is a joke</title>
<description>&lt;p&gt;I've written about &lt;a href="http://pomax.github.io/1436836360570/we-are-really-terrible-at-digital-colours-and-digital-photography"&gt;how bad we are at digital photography from a technical perspective&lt;/a&gt; before, but now that I own a high end mobile device with a decent camera and screen (I was using a &lt;a href="https://en.wikipedia.org/wiki/Nokia_N900"&gt;Nokia N900&lt;/a&gt; for my phone needs until a few weeks ago. Now it's exclusively my alarm clock), it is a constant source of frustration how terrible photography on $700 and above mobile devices is. Certainly, you could argue that they're phones, not cameras, but then you've not really been paying attention to what people actually &lt;em&gt;use&lt;/em&gt; their phones for, where photography ranks considerably higher than calls.&lt;/p&gt;
&lt;p&gt;I have a &lt;a href="https://store.google.com/product/nexus_6p"&gt;Nexus 6P&lt;/a&gt; now, which is a high end Android device with —on paper— a rather good camera, and a very nice AMOLED screen. However, photographs taken with it, no matter whether that's done with the native camera app, &lt;a href="http://www.magix.com/ca/apps/cameramx/"&gt;CameraMX&lt;/a&gt;, &lt;a href="http://www.camerafv5.com/"&gt;Camera FV-5&lt;/a&gt;, or &lt;a href="http://opencamera.sourceforge.net/"&gt;Open Camera&lt;/a&gt;, unless I treat the phone as "half the work", none of the pictures it takes are worth anything if my intention is to share them with the rest of the world, because while I might see "nice, vibrant colours", the moment  I post that picture online people will see completely different colours than I'm getting on my phone. All the edits I made, even with $10 or $25 image processing apps, were nothing but a waste of time and potentially money unless I share it with other Nexus 6P users exclusively of course. And that's not happening for many and obvious reasons. &lt;/p&gt;
&lt;h2 id="colour-calibration-or-the-lack-thereof"&gt;Colour calibration - or, the lack thereof&lt;/h2&gt;
&lt;p&gt;If you care about your colours —and most photographers do, regardless of whether they're hobbyists or professionals— you need colour calibration. On desktop this means colour calibrating your monitor (either with an expensive calibrator like a &lt;a href="http://spyder.datacolor.com/portfolio-view/spyder5pro"&gt;SpyderPro&lt;/a&gt;, or with some &lt;a href="https://blog.adafruit.com/2011/11/14/colorhug"&gt;open source and open hardware&lt;/a&gt; and personal effort), so that the colours it displays are the colours you shot (constrained by the absolute nonsense that is our acceptance of &lt;a href="https://en.wikipedia.org/wiki/Gamut"&gt;color gamuts&lt;/a&gt;, where even in 2016 we collectively don't seem to care that screens literally cannot display about half the colours the human eye sees in the real world - where's universal &lt;a href="https://en.wikipedia.org/wiki/Ultra-high-definition_television"&gt;UHDTV&lt;/a&gt; and &lt;a href="https://en.wikipedia.org/wiki/Rec._2020"&gt;Rec. 2020&lt;/a&gt; support in regular consumer displays?).&lt;/p&gt;
&lt;p&gt;And, it means shooting a &lt;a href="https://www.google.ca/search?q=color+profile+target&amp;amp;tbm=isch"&gt;profiling target&lt;/a&gt; with your camera because calibration has to pass through every display chip: even if your monitor is calibrated, you still need to make sure that the color incorrectness of your camera can be compensated for as well (and oh boy can cameras be wrong)&lt;/p&gt;
&lt;p&gt;So on an Android "phone" we have the same problem, but in a single device. We need to be able to calibrate the screen, because those fancy, super bright, super clear AMOLED screens actually get colour &lt;strong&gt;super wrong&lt;/strong&gt;, and we need to be able to do shot calibration through the camera. &lt;/p&gt;
&lt;p&gt;Neither of those things are possible.&lt;/p&gt;
&lt;h2 id="calibrating-the-screen"&gt;Calibrating the screen&lt;/h2&gt;
&lt;p&gt;If you were smart enough to, after getting your Android device, immediately install an &lt;a href="https://source.android.com"&gt;AOSP&lt;/a&gt; firmware instead, or even something like &lt;a href="http://www.cyanogenmod.org"&gt;CyanogenMod&lt;/a&gt;, you might think you have a leg up, because your enriched version of Android actually comes with colour calibration. Except it really doesn't, all it does is come with global &lt;a href="https://en.wikipedia.org/wiki/Color_balance"&gt;colour &lt;em&gt;balancing&lt;/em&gt;&lt;/a&gt;: you have the ability to control what the &lt;a href="https://en.wikipedia.org/wiki/White_point"&gt;white point&lt;/a&gt; for your screen is, but that's it. If your screen's blues are a bit too red, and the reds are a bit too yellow, then no matter how much you fiddle with that white point, you're going to solve only one of those issues, while exacerbating the other.  Sure, it might make the AMOLED screen "less yellow", but that doesn't help us when it comes to making sure the colours we shoot with the device camera(s) match what they actually were (again, as constrained by the gamut we're forced to use).&lt;/p&gt;
&lt;p&gt;Real calibration measures the response curves for each of the primaries that a display can generate, as well as the intensity responses curves for "greys" (with each primary firing at the same supposed intensity), and builds an ICC profile that lets the device tell the display how to change primary intensities independently of one another. Unlike a white point shift, where the display essentially just renders colours with an overlay filter, without looking at individual pixel values, true colour calibration involves rewriting colour values for every individual pixel.&lt;/p&gt;
&lt;p&gt;And for reasons that I do not understand, &lt;a href="http://www.apple.com/ca/shop/buy-iphone/iphone6"&gt;$1000 imaging devices&lt;/a&gt; that you carry around in your pocket can't do that, whereas even a $25 graphics card in an ancient computer running Windows XP will happily apply an ICC profile for you. &lt;em&gt;Surely&lt;/em&gt; this is not a technical limitation at this point.&lt;/p&gt;
&lt;h2 id="calibrating-the-camera"&gt;Calibrating the camera&lt;/h2&gt;
&lt;p&gt;Camera calibration is more interesting because the only way to properly calibrate the output for a camera sensor is to take pictures of things with known colour values (still constrained to the gamut used for those colours values) and then compute the difference curves between "what the camera saw" and "what it should have reported seeing".&lt;/p&gt;
&lt;p&gt;One problem here is that your eye has been fooling you for as long as you've been alive, and your brain rarely, if ever, notices that it is supremely good at lighting condition compensation. Differences in material properties mean that two different objects under two different lighting conditions will reflect different colours, &lt;em&gt;non-uniformly&lt;/em&gt;: a matte white plaster and high gloss white plastic ball may reflect daylight in a way that lets us compute the difference between the white we think the objects should be, and the &lt;a href="https://en.wikipedia.org/wiki/Color_temperature"&gt;blueish&lt;/a&gt; colour that the objects actually are in sunlight. But if we change the lighting to halogen floodlights, the difference in absorption and reflection in the different materials means that the difference in colour between the two balls is &lt;em&gt;different&lt;/em&gt; from the difference in colour between them in sunlight.&lt;/p&gt;
&lt;p&gt;Color calibration is hard. &lt;/p&gt;
&lt;p&gt;This is why you'll see photographers carry around calibration targets: cards printed with specific colours on them that they'll periodically take pictures of during shoots so that during post processing they can ensure that for every shot under specific lighting conditions, there is a way to determine what the correction should look like. While display calibration is fairly static, scene calibration is a constant necessity.&lt;/p&gt;
&lt;p&gt;Unfortunately, even though there are a number of commonly used scene calibration targets, neither Android nor IOS have ways to tell the phone itself to take a calibration with "calibration target X" so that the camera data that gets sent to a camera app is correct, which means that scene calibration on a mobile device is still the same as in traditional photography:  take a picture of a calibration target every now and then, and then "fix things in post".&lt;/p&gt;
&lt;p&gt;Except if you just have a mobile device, there &lt;strong&gt;is&lt;/strong&gt; no reasonable post processing. There are no apps that perform batch corrects, there are no apps that can abstract a correction profile off of an &lt;a href="https://en.wikipedia.org/wiki/IT8"&gt;IT8&lt;/a&gt; or &lt;a href="http://xritephoto.com/colorchecker-passport-photo"&gt;ColorChecker&lt;/a&gt; target, there are no apps that can load or embed &lt;a href="https://en.wikipedia.org/wiki/ICC_profile"&gt;ICC profiles&lt;/a&gt; into images. There is nothing, and so the only way to do half-decent photography with a $1000 device that is both camera and computer, is to have a &lt;strong&gt;second&lt;/strong&gt; computer with a desktop operating system and real photo processing software.&lt;/p&gt;
&lt;h2 id="why-are-you-complaining-just-use-a-real-camera-then"&gt;Why are you complaining, just use a real camera then&lt;/h2&gt;
&lt;p&gt;Fair enough. I have several real cameras, but that's exactly why I'm going to invoke one of my favourite quotes in recent years in a moment: my phone costs $700; that's an insane amount of money if all it could do was call and text, and so it can do a lot more. It has a high performance CPU and GPU, it has a high quality screen, and two (not just one) high resolution, high quality fixed aperture cameras. And you're asking why I should expect to be able to do a thing that literally 100% of users of this kind of device do dozens of times a day, with a quality that reflects the price and quality of the hardware I'm using, instead of "in the gimpiest broken way possible"? I'll tell you why, and here's that quote:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;"Because this is bullshit, and we can fix this."&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;(Do you work on any Android camera apps? Please bake in profile support to your app. Do you work on Android? Please start taking colour seriously, people use phones to share images, not take pics and only ever view them on their own phone. Do you care about your friends seeing the same photo as the one you saw on your phone? Complain to the former two groups, or become part of them. As for me: the complaints will continue until &lt;s&gt;morale&lt;/s&gt; support improves)&lt;/p&gt;
</description>
<category>Mobile</category>
<category>Photography</category>
<category>Android</category>
<category>IOS</category>
<category>Color</category>
<category>Calibration</category>
<link>http://pomax.github.io/#gh-weblog-1466701364674</link>
<guid>http://pomax.github.io/#gh-weblog-1466701364674</guid>
<pubDate>Thu, 23 Jun 2016 17:02:44 GMT</pubDate>
</item>
<item>
<title>I started a Youtube channel.</title>
<description>&lt;p&gt;I like &lt;a href="https://imgur.com"&gt;imgur.com&lt;/a&gt;, it's a great way to both fill moments of downtime with some interesting pictures posts, as well as waste too much time trying to find the next picture post, but one of the things that gets posted with reasonable frequency is food pictures, and they're always these high speed, "it's so easy just do this!" recipe gifs. &lt;/p&gt;
&lt;p&gt;While I won't contest that there are easy recipes, provided you do your prep first, cooking -and baking- takes time, and I wanted to create something that shows off &lt;em&gt;that&lt;/em&gt; aspect of kitchen work.  So, I started a Youtube channel over on &lt;a href="https://www.youtube.com/channel/UC_vhEBO8O9ABn1f32KuUtjw"&gt;https://www.youtube.com/channel/UC_vhEBO8O9ABn1f32KuUtjw&lt;/a&gt;, starting with a video series on &lt;a href="https://www.youtube.com/playlist?list=PL5_wrS2aqN9YFaSCWbpo-OEvbytigJWMY"&gt;making baguette&lt;/a&gt;, start to finish. Baguette is not "easy", and it's not "fast"; any recipe that claims it is is either lying or selling you something (thanks "&lt;a href="http://www.imdb.com/title/tt0093779"&gt;The Princess Bride&lt;/a&gt;"!) but it is entirely doable, provided you follow all the steps, and all the steps take time. So I took mine and made 15 videos that document the process in real time, except for the "in the oven" videos, which are sped up because seeing what the dough does actually teaches you something.&lt;/p&gt;
&lt;p&gt;And since it would be a shame to just do one kitchen video series and then sell the cameras I used again, I'll be trying to post some new series every now and then. For now, that means there's a video series for &lt;a href="https://www.youtube.com/playlist?list=PL5_wrS2aqN9aPVEKij5gDLf91UoapIrWH"&gt;Romano Pizza&lt;/a&gt; and a video series for &lt;a href="https://www.youtube.com/playlist?list=PL5_wrS2aqN9Z7RYLc9-npfsMRH0hXUQut"&gt;Chicken Shepherd's Pie&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;It's fun to do, obviously it's food that gets eaten after it gets made, and if you're tired of "an hour of work in 30 seconds" like I am, hit me up, I'm sure you have ideas I am interested in.&lt;/p&gt;
</description>

<link>http://pomax.github.io/#gh-weblog-1464027515789</link>
<guid>http://pomax.github.io/#gh-weblog-1464027515789</guid>
<pubDate>Mon, 23 May 2016 18:18:35 GMT</pubDate>
</item>
<item>
<title> HTTPS, Mixed Content, and the real web... oh my!</title>
<description>&lt;p&gt;We recently fixed something around Mozilla's X-Ray Goggles. A long running problem that caused people headaches and the feeling of lost work, while at the same time doing nothing "wrong", from a technical perspective. This is going to be a story about how modern browsers work, how people use the web, and how those two things... don't always align.&lt;/p&gt;
&lt;h2 id="x-ray-goggles-by-mozilla"&gt;X-Ray Goggles by Mozilla&lt;/h2&gt;
&lt;p&gt;So let's start with X-Ray Goggles: the X-Ray Goggles are &lt;a href="https://goggles.mozilla.org"&gt;a tool&lt;/a&gt; made by &lt;a href="https://mozilla.org"&gt;Mozilla&lt;/a&gt; that lets you "remix" web pages after loading them in your browser. You can go to your favourite place on the web, fire up the goggles (similar to how a professional web developer would open up their dev tools), and then change text, styling, images, and whatever else you might want to change, for as long as you want to change things, and then when you're happy with the result and you want to show your remix to your friends, you can publish that remix so that it has its own URL that you can share.&lt;/p&gt;
&lt;p&gt;However, the X-Ray Goggles use a publishing service that hosts all its content over &lt;code&gt;https&lt;/code&gt;, because we care about secure communication at Mozilla, and using &lt;code&gt;https&lt;/code&gt; is best practice. But in this particular case, it's also kind of bad: large parts of the web still use &lt;code&gt;http&lt;/code&gt;, and even if a website has an &lt;code&gt;https&lt;/code&gt; equivalent, people usually visit the &lt;code&gt;http&lt;/code&gt; version anyway. Unless those websites &lt;em&gt;force&lt;/em&gt; users to the &lt;code&gt;https&lt;/code&gt; version of the site (using a redirect message), then the site they'll be on, and the site they'll be remixing, will use HTTP, and the moment the user publishes their remix with X-Ray Goggles and they get an &lt;code&gt;https&lt;/code&gt; URL back, and then open that URL in their browser....&lt;/p&gt;
&lt;p&gt;well, let's just say "everything looks broken" is not wrong. &lt;/p&gt;
&lt;p&gt;But the reason for this is not because Goggles, or even the browser is doing something wrong - ironically, it's because they're doing something right, and in so doing, what the user wants to do turns out incompatible with what the technology wants them to do. So let's look at what's going on here.&lt;/p&gt;
&lt;h2 id="http-the-basis-upon-which-browsing-is-built"&gt;HTTP, the basis upon which browsing is built&lt;/h2&gt;
&lt;p&gt;If you're a user of the web, no doubt you'll have heard about &lt;code&gt;http&lt;/code&gt; and &lt;code&gt;https&lt;/code&gt;, even if you can't really say what they technically-precisely mean. In simple terms (but without dumbing it down), &lt;a href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol"&gt;HTTP&lt;/a&gt; is the language that servers and browsers use to negotiate data transfers. The original intention was for those two to talk about HTML code, so that's where the &lt;code&gt;h&lt;/code&gt; in &lt;code&gt;http&lt;/code&gt; comes from (it stands for "hypertext" in both &lt;code&gt;http&lt;/code&gt; and &lt;code&gt;html&lt;/code&gt;), but we're mostly ignoring that these days, and HTTP is used by browsers and servers to negotiate transmission of all sorts of files - web pages, stylesheets, javascript source code, raw data, music, video, images, you name it.&lt;/p&gt;
&lt;p&gt;However, HTTP is a bit like regular English: you can listen in on it. If you go to a bar and sit yourself with a group of people, you can listen to their conversations. The same goes for HTTP: in order for your browser and the server to talk they rely on a chain of other computers connected to the internet to get messages relayed from one ot the other, and any of those computers can listen in on what the browser and server are saying to each other. In an HTTP setting it gets a little stranger even, because any of those computers could look at what the browser or server are saying, &lt;em&gt;replace what is being said with something else&lt;/em&gt; and then forward that on. And you'll have no way of knowing whether that's what happened. It's literally as if the postal service took a letter you sent, opened it, rewrote it, resealed it, and then sent that on. We trust that they won't, and computers connected to the internet trust that other computers don't mess with the communication, but... they can. And sometimes they do.&lt;/p&gt;
&lt;p&gt;And that's pretty scary, actually. You don't want to have to "trust" that your communication isn't read or tampered with, you want to &lt;em&gt;know&lt;/em&gt; that's the case.  &lt;/p&gt;
&lt;h2 id="what-can-we-do-to-fix-that-"&gt;What can we do to fix that?&lt;/h2&gt;
&lt;p&gt;Well, we can use &lt;a href="https://en.wikipedia.org/wiki/HTTPS"&gt;HTTPS&lt;/a&gt;, or "secure HTTP", instead. Now, I need to be very clear here: the term "secure" in "secure HTTP" refers to secure &lt;em&gt;communication&lt;/em&gt;. Rather than talking "in English", the browser and server agree on a secret language that you could listen to, but you won't know what's being said, and so you can't intercept-and-modify the communication willy-nilly without both parties knowing that their communications are being tampered with. However it does &lt;strong&gt;not&lt;/strong&gt; mean that the data the browser and server agree to receive or send is "safe data". It only means that both parties can be sure that what one of them receives is what the other intended to send. All we can be sure of is that no one will have been able to see what got sent, and that no one modified it somewhere along the way without us knowing.&lt;/p&gt;
&lt;p&gt;However, those are &lt;em&gt;big&lt;/em&gt; certainties, so for this reason the internet's been moving more and more towards preferring HTTPS for everything. But not everyone's using HTTPS yet, and so we run into something called the &lt;a href="https://developer.mozilla.org/en-US/docs/Security/Mixed_content"&gt;"Mixed Content"&lt;/a&gt; issue.&lt;/p&gt;
&lt;h2 id="let-s-look-at-an-example-"&gt;Let's look at an example.&lt;/h2&gt;
&lt;p&gt;Imagine I run a web page, much like this one, and I run it on HTTP because I am not aware of the security issues, and my page relies on some external images, and some JavaScript for easy navigation, and maybe an embedded podcast audio file. All of those things are linked as &lt;code&gt;http://......&lt;/code&gt;, and everything worked fine.&lt;/p&gt;
&lt;p&gt;But then I hear about the problems with HTTP and the privacy and security implications sound horrible! So, to make sure my visitors don't have to worry about whether the page they get from my server is my page, or a modified version of my page, I spring into action, I switch my page over to HTTPS; I get a &lt;a href="https://en.wikipedia.org/wiki/Public_key_certificate"&gt;security certificate&lt;/a&gt;, I set everything on my own server up so that it can "talk" in HTTPS, and done!&lt;/p&gt;
&lt;p&gt;Except immediately after switching, my web page is completely broken! The page itself loads, but none of the images show up, and the JavaScript doesn't seem to be working, and that podcast embed is gone! What happened??&lt;/p&gt;
&lt;p&gt;This is a classic case of &lt;strong&gt;mixed-content blocking&lt;/strong&gt;. My web page is being served on HTTPS, so it's indicating that it wants to make sure everything is secure, but the resources I rely on still use HTTP, and now the browser has a problem: it can't trust those resources, because it can't trust that they won't have been inspected or even modified when it requests them, and because the web page that's asking them to be loaded expressed that it cares about secure communication a great deal, the browser can't just fetch those insecure elements, things &lt;em&gt;might&lt;/em&gt; go wrong, and there's no way to tell!&lt;/p&gt;
&lt;p&gt;So it does the only thing it knows is safe: better safe than sorry, and it flat out refuses to even request them, giving you a warning about "mixed content".&lt;/p&gt;
&lt;p&gt;Normally, that's great. It lets people who run websites know that they're relying on potentially insecure third party content in an undeniably clear way, but it gets a bit tricky in two situations:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;third party resources that &lt;em&gt;themselves&lt;/em&gt; require other third party resources, and&lt;/li&gt;
&lt;li&gt;embedding and rehosting&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The first is things like your web page using a comment thread service: your web page includes a bit of JavaScript from something like &lt;code&gt;www.WeDoCommentsForYou.com&lt;/code&gt; and then that JavaScript then loads content from that site's comment database, for instance &lt;code&gt;comments.WeDoCommentsForYou.com&lt;/code&gt;. If we have a page that uses HTTPS, running on &lt;code&gt;https://ourpage.org&lt;/code&gt; then we can certainly make sure that we load the comment system from &lt;code&gt;https://www.WeDoCommentsForYou.com&lt;/code&gt;, but we don't control the protocol for the URL that the JavaScript we got back uses. If "WeDoCommentsForYou" wrote their script poorly, and they try to load their comments over &lt;code&gt;http://&lt;/code&gt;, then too bad, the browser will block that. Sure, it's a thing that "WeDoCommentsForYou" should fix, but until they do your users can't comment, and that's super annoying.&lt;/p&gt;
&lt;p&gt;The second issue is kind of like the first, but is about entire web pages. Say you want to embed a page; for instance, you're &lt;a href="https://en.wikipedia.org/wiki/Transclusion"&gt;transcluding&lt;/a&gt; an entire wiki page into another wiki page. If the page you're embedding is &lt;code&gt;http&lt;/code&gt; and the page it's embedded on is &lt;code&gt;https&lt;/code&gt;, too bad, that's not going to work. Or, and that brings us to what I really want to talk about, if you remix a page on &lt;code&gt;http&lt;/code&gt;, with &lt;code&gt;http&lt;/code&gt; resources, and host that remix on a site that uses &lt;code&gt;https&lt;/code&gt;, then that's not going to work either...&lt;/p&gt;
&lt;h2 id="back-to-the-x-ray-goggles"&gt;Back to the X-Ray Goggles&lt;/h2&gt;
&lt;p&gt;And that's the problem we were hitting with X-Ray Goggles, too.&lt;/p&gt;
&lt;p&gt;While the browser is doing the same kind of user protection that it does for any other website, in this particular case it's actually a big problem: if a user remixed an HTTP website, then knowing what we know now, &lt;em&gt;obviously&lt;/em&gt; that's not going to work if we try to view it using HTTPS. But that also means that instead of a cool tool that people can use to start learning about how web pages work "on the inside", the result of which they can share with their friends, they have a tool that lets them look at the insides of a web page and then when they try to share their learning, everything breaks.&lt;/p&gt;
&lt;p&gt;That's not cool.&lt;/p&gt;
&lt;p&gt;And so the solution to this problem is based on first meeting the expectations of people, and then educating them on what those expectations actually mean.   &lt;/p&gt;
&lt;h2 id="give-me-https-unless-i-started-on-http"&gt;Give me HTTPS, unless I started on HTTP&lt;/h2&gt;
&lt;p&gt;There are quite a few solutions to the mixed-content problem, and some are better than others. There are some that are downright not nice to other people on the web (like making a full copy of someone's website and then hosting that on Mozilla's servers. That's not okay), or may open people up exploits (like running a proxy server, which runs on HTTPS and can fetch HTTP resources, then send them on as if they were on HTTPS, effectively lying about the security of the communication), so the solution we settled on is, really, the simplest one:&lt;/p&gt;
&lt;p&gt;If you remix an &lt;code&gt;http://...&lt;/code&gt; website, we will give you a URL that starts with &lt;code&gt;http://&lt;/code&gt;, and if you remix an &lt;code&gt;https://&lt;/code&gt; website, we will give you a URL that starts with &lt;code&gt;https://...&lt;/code&gt;. However, we also want you to understand what's going on with the whole "&lt;code&gt;http&lt;/code&gt; vs &lt;code&gt;https&lt;/code&gt;" thing, so when you visit a remix that starts with &lt;code&gt;http://&lt;/code&gt; the remix notice bar at the top of the page also contains a link to the &lt;code&gt;https://&lt;/code&gt; version --same page, just served using HTTPS instead of HTTP-- so that you can see exactly how bad things get if you can't control which protocol gets used for resources on a page.&lt;/p&gt;
&lt;h2 id="security-vs-usability"&gt;Security vs Usability&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.mozilla.org/en-US/security"&gt;Security is everybody's responsibility&lt;/a&gt;, and explaining the risks on the web that are inherent to the technology we use every day is always worth doing. But that doesn't mean we need to lock everything down so "you can't use it, the end, go home, stop using HTTP". That's not how the real world works.&lt;/p&gt;
&lt;p&gt;So we want you to be able to remix your favourite sites, even if they're HTTP, and have a learning/teaching opportunity there around security. Yes, things will look bad when you try to load an HTTP site on HTTPS, but there's a reason for that, and it's important to talk about it.&lt;/p&gt;
&lt;p&gt;And it's equally important to talk about it without making you lose an hour or more of working on your awesome remix.&lt;/p&gt;
</description>
<category>Mozilla</category>
<category>X-Ray Goggles</category>
<category>http</category>
<category>https</category>
<category>browsers</category>
<category>internet</category>
<link>http://pomax.github.io/#gh-weblog-1462301193409</link>
<guid>http://pomax.github.io/#gh-weblog-1462301193409</guid>
<pubDate>Tue, 03 May 2016 18:46:33 GMT</pubDate>
</item>
<item>
<title>I wrote a  script for Photoshop to export paths as SVG files</title>
<description>&lt;p&gt;Ever drawn some paths in &lt;a href="https://adobe.com"&gt;Adobe&lt;/a&gt;'s &lt;a href="https://adobe.com/photoshop"&gt;Photoshop&lt;/a&gt;, and wanted to export those paths for use in something that &lt;strong&gt;isn't&lt;/strong&gt; Adobe Illustrator? Because that's kind of ... impossible. Photoshop lets you export your working paths specifically for Illustrator, using the &lt;code&gt;.ia&lt;/code&gt; format, but if you want to load it in something else? And heaven forbid, some Open Source package that doesn't even support proprietary formats? You have a problem.&lt;/p&gt;
&lt;p&gt;Or, "had", because now you can export your paths to SVG instead. I needed this functionality for some glyph tracing I'm doing (tracing in Photoshop, but ultimately the glyph needs to end up in &lt;a href="http://fontforge.github.io"&gt;FontForge&lt;/a&gt;) and as it so happens I know that Photoshop &lt;a href="https://www.adobe.com/content/dam/Adobe/en/products/photoshop/pdfs/cs6/Photoshop-CS6-JavaScript-Ref.pdf"&gt;has a Javascript API&lt;/a&gt;. So how hard could it be to create an "export to SVG" option?&lt;/p&gt;
&lt;p&gt;Well... sort of hard. While PS supports JS, the API it has uses a &lt;em&gt;&lt;a href="https://en.wikipedia.org/wiki/JavaScript#Version_history"&gt;truly ancient&lt;/a&gt;&lt;/em&gt; version of Javascript (v1.3 from what I can tell.. an almost 20 year old flavour), so there were some things that we pretty much rely on these days that simply didn't exist back then. Basic things like &lt;code&gt;Array.forEach&lt;/code&gt; aren't supported, so after writing shims for &lt;a href="https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach"&gt;forEach&lt;/a&gt;, &lt;a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map"&gt;map&lt;/a&gt; and &lt;a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/keys"&gt;Object.keys&lt;/a&gt;, I was able to write a script that lets you simply call &lt;em&gt;file&lt;/em&gt; → &lt;em&gt;scripts&lt;/em&gt; → &lt;em&gt;browse&lt;/em&gt; and then run it, which immediately generates the SVG code for all your paths as a single SVG document and copies the code for it into your clipboard.&lt;/p&gt;
&lt;p&gt;Internally, Photoshop stores paths as "multiple paths per document", with "multiple sub-paths per path", and each sub-path consists of an array of points. These points can either be corner points or "smooth" points, meaning they're Bezier curve points, and that's all the information you get.&lt;/p&gt;
&lt;p&gt;Of course, while this is a normal way to encode data, &lt;a href="https://www.w3.org/TR/SVG/paths.html#PathData"&gt;SVG path instructions&lt;/a&gt; are of the form "Line to x/y" or "Cubic curve over c1 and c2 to x/y", so in order to generate the correct path instructions, the code needs to walk over each sub-path using a two point window, and check whether it's generating code for going from corner to corner, corner to curve, curve to corner, or curve to curve; each of those four has a different way to unpack the information contained by the two points into a single SVG pathing instruction.&lt;/p&gt;
&lt;p&gt;But, with that done, the result is a Photoshop script that with just a few clicks drops your entire working path collection into an SVG document in your clipboard. If that sounds useful to you, head on over to &lt;a href="https://github.com/Pomax/photoshop-paths-to-SVG"&gt;https://github.com/Pomax/photoshop-paths-to-SVG&lt;/a&gt; and grab the script for yourself.&lt;/p&gt;
&lt;p&gt;And  of course it's open source, so let me know if you find it useful or have ideas on how to improve it!&lt;/p&gt;
</description>
<category>Photoshop</category>
<category>Javascript</category>
<category>SVG</category>
<category>Paths</category>
<link>http://pomax.github.io/#gh-weblog-1457651549619</link>
<guid>http://pomax.github.io/#gh-weblog-1457651549619</guid>
<pubDate>Thu, 10 Mar 2016 23:12:29 GMT</pubDate>
</item>
<item>
<title>Github changes to icon SVG from fonts, for no clear reason</title>
<description>&lt;p&gt;In a &lt;a href="https://github.com/blog/2112-delivering-octicons-with-svg"&gt;recent post on their blog&lt;/a&gt;, &lt;a href="github.com"&gt;github&lt;/a&gt; announced that  they've moved away from icon fonts in favour of SVG. In itself perfectly fine, use whatever works best, and if fonts aren't working for you, switch; but their explanation of what was wrong makes several kinds of no sense.&lt;/p&gt;
&lt;p&gt;This is going to be a bit of a rant, it's going to conclude with "should they switch? absolutely! yay github" but the rest of the text is about how their blog post doesn't feel like it actually contains any proper rationale for the move. You can stop reading if you only wanted to know my concluding thoughts. As far as I'm concerned, they did the right thing, for the wrong reasons.&lt;/p&gt;
&lt;p&gt;Also, I've &lt;a href="http://stackoverflow.com/a/30821089/740553"&gt;talked about this on Stackoverflow&lt;/a&gt; before, so if you ever ran into that post, the following analysis should not come as anything even close to a surprise to you.&lt;/p&gt;
&lt;h2 id="showing-the-problem"&gt;Showing the problem&lt;/h2&gt;
&lt;p&gt;The post starts with images that show a "badly blurred font icon" vs "a nicely crisp image icon", except what it really shows are two equally blurry, terrible images. Neither is particularly better than the other at the scale shown; they're differently blurry, but they're both terrible, and using this as a highlight of the problem shows that (unsurprisingly) a vector approach to icons is a weird solution to a problem predominantly &lt;a href="http://rastertragedy.com"&gt;caused by small-scale rendering of graphics designed using large scale units&lt;/a&gt;. They're both bad, so the rest of the post better be good at explaining why you want the lesser of two "evils" instead of finding a third "good".&lt;/p&gt;
&lt;h2 id="icon-font-rendering-issues"&gt;Icon font rendering issues&lt;/h2&gt;
&lt;p&gt;The first section is 100% true. Github notes that "Icon fonts have always been a hack", and they have. Unicode these days comes with dingbats/windings, symbol sets, and emoji, but none of those things are true icons. Icon fonts will typically either inappropriately use "real letter" code points for icons ("you use class &lt;code&gt;.left-arrow&lt;/code&gt; but it renders because it asks the letter &lt;code&gt;a&lt;/code&gt; from the font, which happens to be an icon) or they use PUA (the Private Use Area of fonts) and some kind of substitution ruleset for finding icons in that area (because you can't really type PUA letters on your keyboard).&lt;/p&gt;
&lt;p&gt;So far so good. Except that's not a reason to switch, that's merely stating the facts. Fonts for icons are hacks. Do they get the job done? Certainly. This does not count towards the "reasons to switch" yet.&lt;/p&gt;
&lt;h2 id="page-rendering-improvements"&gt;Page rendering improvements&lt;/h2&gt;
&lt;p&gt;There was an assumption that SVG would improve page performance. However, as they note later, &lt;a href="https://cloud.githubusercontent.com/assets/54012/13176951/eedb1330-d6e3-11e5-8dfb-99932ff7ee25.png"&gt;there's no clear evidence of that&lt;/a&gt;. To be clear: this is completely the right thing to do: you have two possible options, you test both, and then use metrics to determine which one is better. But if there is no real difference then it cannot count as reason to switch. It is in fact a reason to tell others "if this is why you're thinking of switching, it doesn't matter, here's our findings: ..."&lt;/p&gt;
&lt;p&gt;So far, we have no justifiable reason to switch yet (other than just "let's do this").&lt;/p&gt;
&lt;h2 id="accessibility"&gt;Accessibility&lt;/h2&gt;
&lt;p&gt;This one's interesting. "some people use their own fonts, so our fonts don't render" may be a problem. Github has &lt;em&gt;a lot&lt;/em&gt; of users, but "people using their own fonts" typically also means those people do so by choice. If overriding the icon font is adverse, they presumably have the power to each fix that, but chose not to. That's not Github's responsibility to fix, but it can certainly be something Github can fix "as one party" instead of every user who's affected fixing it "as a million parties". It's not an argument to switch from fonts to SVG in general, but it's an argument for Github, as a trusted and liked millions-of-users-daily service, to lend a helping hand.&lt;/p&gt;
&lt;p&gt;The second argument concerns screen readers, but glosses over the nature of an icon in a UI. Icons are non-semantic, they're decoration around the actual thing. The hypothetical ability to add readable &lt;code&gt;alt&lt;/code&gt; texts because the icons are now true images does not apply: if your icon needs an alt-text read out to the user in order for them to understand your UI, that icon is not an icon, it's a genuine semantic element and you should not be using an icon to hide what it is. In fact, you confuse &lt;em&gt;everyone&lt;/em&gt; with that kind of icon use, not just people who need, or are better served by using, screen readers.&lt;/p&gt;
&lt;h2 id="properly-sized-glyphs"&gt;Properly sized glyphs&lt;/h2&gt;
&lt;p&gt;This one's a bit odd, because it both makes sense and absolutely not. I'm paraphrasing, but this section has a rational along the lines of "vector fonts render horribly at small point sizes", which is &lt;a href="http://rastertragedy.com"&gt;absolutely true&lt;/a&gt;, "as opposed to SVG, which renders pixel-perfect", which is absolutely false.  Both are vector graphics, and both suffer from the exact same problem scaled down. However, fonts can come with instructions on how to correct outlines, and SVG cannot. Unfortunately the choice between &lt;code&gt;ttf&lt;/code&gt; and &lt;code&gt;otf&lt;/code&gt; matters &lt;em&gt;a lot&lt;/em&gt; here: &lt;code&gt;ttf&lt;/code&gt; uses true instructions, and &lt;code&gt;otf&lt;/code&gt; uses hints. If you try to use an &lt;code&gt;otf&lt;/code&gt; icon font with a render engine that doesn't have a good "what should I do with these hints" implementation, your icons will look terrible. Turns out that's the state of technology right now. So that's an argument to use &lt;code&gt;ttf&lt;/code&gt; rather than &lt;code&gt;otf&lt;/code&gt;, rather than exchanging one vector format for another.&lt;/p&gt;
&lt;p&gt;The blog post does talk about SVG not getting subpixel-hinted, which "fixes" things, but if that's the case you've found a bug in the text render pipeline: file that so it can be fixed. In fact as &lt;a href="https://twitter.com/Keyamoon/status/703530343169560576"&gt;Keyamoon points out&lt;/a&gt;, this is not the case in Firefox, and &lt;em&gt;wasn't&lt;/em&gt; the case in previous versions of Chrome. As arguably the most important playing in Open Source Software at the moment, I would expect Github to help get this fixed instead of walking away from a problem like that.&lt;/p&gt;
&lt;p&gt;But why go from one vector format to another? Vector graphics are always worse than bitmaps if you want pixel-perfect icons, so: why not  keep using fonts, with bitmaps for the "it scales poorly" cases? I know what you're thinking: "but modern fonts are vector fonts!" Not really, no. Modern fonts can do &lt;em&gt;a lot&lt;/em&gt; of things, and one of those things is that they can contain pixel-perfect bitmaps to be used when a sequence of glyphs needs to be shaped at &lt;em&gt;specific&lt;/em&gt; point sizes, for pixel-perfect rendering (using the EBDT, Embedded Bitmap Data Table). If your icon font of choice doesn't come with those, then that's an argument for improving things on the font side, so that everyone who uses that font gets a better deal out of it.&lt;/p&gt;
&lt;p&gt;Of course, in the mean time you might consider changing over to SVG because you want to solve the problem "now", and I like Github and assume they looked and couldn't find one. But as phrased, this section didn't actually give a good rationale for switching to SVG so much as highlighted a misunderstanding on how modern fonts work and showing that assumptions were made about what the problem was, leading to an action that doesn't &lt;em&gt;solve&lt;/em&gt; the problem: to someone familiar with the inner workings of fonts, this section reads as a symptom description, not a problem description, and fixing the symptom does not solve the underlying problem. &lt;em&gt;Any vector graphic&lt;/em&gt; will render terribly at low point sizes, trading one for another just &lt;a href="https://en.wikipedia.org/wiki/Buck_passing"&gt;passes the buck&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="ease-of-authoring"&gt;Ease of authoring&lt;/h2&gt;
&lt;p&gt;No two ways about it: if you want to control your icons, SVG is a hell of a lot easier than fonts. Go with SVG! It's the right choice! &lt;/p&gt;
&lt;h2 id="we-can-animate-them"&gt;We can animate them&lt;/h2&gt;
&lt;p&gt;Get out. If you're arguing accessibility as part of your rationale, don't even go here.&lt;/p&gt;
&lt;h1 id="should-github-switch-"&gt;Should Github switch?&lt;/h1&gt;
&lt;p&gt;Of course they should, it's their site. If they feel better with an SVG solution compared to fonts, then that's all the rationale they need. But then it would be nice if their blog post acknowledged that the only objective justification that was described, performance, turned out to not be significantly impacted by the switch, and that they've gone through with the switch mostly because it's easier to work with from a continuous update perspective, and also quite likely because if you've done all that work already to test deploying SVG instead of fonts, why not flip the switch.&lt;/p&gt;
&lt;p&gt;I'm sure we'd understand that, too.&lt;/p&gt;
</description>
<category>Github</category>
<category>Fonts</category>
<category>SVG</category>
<category>Icons</category>
<link>http://pomax.github.io/#gh-weblog-1456332505750</link>
<guid>http://pomax.github.io/#gh-weblog-1456332505750</guid>
<pubDate>Wed, 24 Feb 2016 16:48:25 GMT</pubDate>
</item>
<item>
<title>You probably need Chocolate Bread Pudding in your life.</title>
<description>&lt;p&gt;I made an &lt;a href="http://imgur.com/gallery/ObTlB"&gt;imgur image album&lt;/a&gt; as an illustrated guide to making chocolate bread pudding - or at least, the kind I make these days (less death-by-chocolate, more tasty-not-too-sweet brownie alternative). If there's requests I'll turn that into a post on this blog, but the imgur link should be pretty stable so for now I'll leave it at that.&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/GDjqsU0.jpg" alt=""&gt;&lt;/p&gt;
</description>
<category>Cooking</category>
<category>Baking</category>
<category>Chocolate</category>
<link>http://pomax.github.io/#gh-weblog-1455215020166</link>
<guid>http://pomax.github.io/#gh-weblog-1455215020166</guid>
<pubDate>Thu, 11 Feb 2016 18:23:40 GMT</pubDate>
</item></channel>
</rss>
